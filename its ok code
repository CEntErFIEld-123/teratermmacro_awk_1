'VBS1
'=!!修正する際は必ずお読みください。!!
'================================================
'日本語を使用しているためは文字コードを「ANSI」にして保存してください。
'使用するファイル・フォルダ名を変更する際は以下の★の項目を修正してください。
'サーバのIPアドレスの修正はttlファイル側を修正してください。
'更新日時：2022/02/01 更新者：
'================================================

'(1)事前設定
Option Explicit '変数を明示的に宣言

'(2)使用する変数の宣言
Dim CdPath 'カレントディレクトリのパス
Dim ScrPath '使用するファイルを格納したパス
Dim ResPath '集計結果を格納するパス
Dim LogsSavePath '操作ログを格納するパス
Dim ttpmacroPath 'テラタームマクロのパス
Dim UseFilesName '使用するTTLファイル、VBSファイル名
Dim LogFilesName 'テラタームマクロがログを記録ファイル名群
Dim UsrInputStr '使用者が入力した値
Dim ReUsrInputStr '使用者が入力した値をリネームした値
Dim SyslogStartDate, SyslogEndDate ,StartDate'TTLファイルへ引き渡す日時の値
Dim Fso 'ファイルシステムオブジェクト用に使用
Dim Shello 'TTLファイルを起動するためのオブジェクト用に使用
Dim CheckStrError, CheckStrNum '入力された値のチェックで使用
Dim CheckMsg 'メッセージの戻り確認に使用
Dim i, j 'カウンターなどに使用

'(3)使用するttlとvbsファイルが存在しているか確認する。
StartDate = Replace(Now(), " ","　") '作業開始日時
Set Fso = CreateObject("Scripting.FileSystemObject")
CdPath = Fso.GetAbsolutePathName(".") 'カレントディレクトリのパスを取得
'★========================================================================
ScrPath = CdPath & "\script\" 'ツール群のパス
ResPath = CdPath & "\結果\" '結果を書き込むファイルのパス
LogsSavePath = CdPath & "\ログ\" '操作ログを書き込むファイルのパス
UseFilesName = Array("GetFileInfo.ttl", "CountIPAddressOutput.vbs") '使用するファイル名群
LogFilesName = Array("操作ログ1.txt", "操作ログ2.txt") 'マクロがログを記録ファイル名群
ttpmacroPath = "C:\Program Files (x86)\teraterm\ttpmacro.exe"
'==========================================================================
 'ファイルの存在チェック
For Each i In UseFilesName
  If Fso.FileExists(ScrPath & i) = False Then
    MsgBox "「script」フォルダに使用する「" & i & "」が存在しません。該当フォルダを確認してください。", vbCritical,"使用するファイルがありません"
    Set Fso = Nothing
    WScript.Quit
  End if
Next
For Each i In LogFilesName
  If Fso.FileExists(ResPath & i) = True Or Fso.FileExists(LogsSavePath & i) = True Then
    MsgBox "「結果」か「操作ログ」フォルダにマクロが書き込む「" & i & "」が存在します。" & vbCr & _
           "退避漏れの可能性があります。ファイルを削除するか退避をしてください。", vbCritical,"マクロがログを書き込むファイルが残っています"
    Set Fso = Nothing
    WScript.Quit
  End If
next
Set Fso = Nothing

'(4)日付の入力処理
CheckStrError = "" '念のため
UsrInputStr = "YYYY/MM/DD hh:mm:ss" '初期値
Do Until CheckStrError = "NoError" '入力された値にエラーがなくなるまでループ
  '使用者へ入力要求
  UsrInputStr = CStr(InputBox("サーバから入力された日時の10分前～5分後までの間にSyslog.logに書き込まれた内容を取得します。" & vbCr & _
   "なお、入力形式は「YYYY/MM/DD hh:mm:ss」です。" & vbCr & _
   "例）2022年1月2日3時4分5秒は、"& vbCr & "  「2022/01/02 03:04:05」となります。" & vbCr & _
   "※何も入力せず「OK」か「キャンセル」を押すと終了できます。" , "データを取得する日時を入力してください。", UsrInputStr))
  If UsrInputStr = "" Then
    msgbox "ツールを終了します。"
    WScript.Quit
  End if
  '(5)入力された値が正しいか確認する。
   'チェック開始
  CheckStrError = ""
  Do While True
    '①文字数の確認
    If Len(UsrInputStr) > 19 Then
      MsgBox "入力された日付の文字数が多いです。もう一度入力してください。", vbCritical,"入力エラー"
      Exit Do
    ElseIf  Len(UsrInputStr) < 19 Then
      MsgBox "入力された日付の文字数が少ないです。もう一度入力してください。", vbCritical,"入力エラー"
      Exit Do
    End if
    '②「/」の確認
    j = 0
    For i = 1 To 2
      j = InStr(j + 1, UsrInputStr, "/")
    Next
    If j <> 8 Then
      MsgBox "入力された日付の年月日の「/」が正しく入力されていません。半角でもう一度入力してください。", vbCritical,"入力エラー"
      Exit Do
    End if
    '③スペースの確認
    j = InStr(UsrInputStr, " ")
    If j <> 11 Then
      MsgBox "入力された日付の年月日と時間の間にスペースが正しく入力されていません。", vbCritical,"入力エラー"
      Exit Do
    End if
    '④「:」の確認
    j = 0
    For i = 1 To 2
      j = InStr(j + 1, UsrInputStr, ":")
    Next
    If j <> 17 Then
      MsgBox "入力された日付の時間の「:」が正しく入力されていません。半角でもう一度入力してください。", vbCritical,"入力エラー"
      Exit Do
    End if
    '⑤数値の判定
    CheckStrNum = Replace(Replace(Replace(UsrInputStr, "/", ""), " ", ""), ":", "")
    If IsNumeric(CheckStrNum) = False Or Len(CheckStrNum) <> 14 Then '数字以外が含まれているか数字が足りない場合エラー
      MsgBox "入力された日付に数字以外が含まれています。もう一度入力してください。", vbCritical,"入力エラー"
      Exit Do
    End if
    '⑥日付の整合性の確認
    If IsDate(UsrInputStr) = true Then
      If Left(UsrInputStr, 2) = 20 Then
        CheckStrError = "NoError" 'エラーなし
        Exit Do
      Else
        MsgBox "入力された日付が西暦20xx年ではありません。もう一度入力してください。", vbCritical,"入力エラー"
        Exit Do
      End if
    Else
      MsgBox "入力された日付に誤りがあります。もう一度入力してください。", vbCritical,"入力エラー"
      Exit Do
    End if
  Loop
   '念のため年月が本日と違っていた場合の確認
  If CheckStrError = "NoError" Then
    If FormatDateTime(Now, vbShortDate) <> FormatDateTime(UsrInputStr, vbShortDate) Then
      CheckMsg = MsgBox("入力された年月日(" & FormatDateTime(UsrInputStr, vbShortDate) & ")と" & vbCr & _
       "本日の年月日(" & FormatDateTime(Now, vbShortDate) & ")に乖離があります。" & vbCr & _
       "本日の年月日と乖離がある状態で実行しますか？", vbyesno + vbExclamation,"年月日に乖離があります")
      If CheckMsg = vbNo then
        CheckStrError = "" '初期化しないとループが終わる
        msgbox "再度入力をお願いします。",vbInformation
      End If
    End if
  End if
Loop

'(6)入力された値から10分前を計算してログ収集開始日時のリネームする。
 'FormatDateTimeを使用する理由は、DateAddだとHHに0が入らないからです
ReUsrInputStr = FormatDateTime(DateAdd("n", -10, UsrInputStr), 2) & Mid(UsrInputStr, 11, 1) & FormatDateTime(DateAdd("n", -10, UsrInputStr), 4) & Right(UsrInputStr, 3)
SyslogStartDate = Replace(Replace(ReUsrInputStr, "/", "-"), " ", "T")
 '念のため
If Len(SyslogStartDate) <> 19 Then SyslogStartDate = Left(UsrInputStr, 2) & SyslogStartDate

'(7)入力された値から5分後の計算をしてログ収集終了日時をリネームする。
ReUsrInputStr = FormatDateTime(DateAdd("n", 5, UsrInputStr), 2) & Mid(UsrInputStr, 11, 1) & FormatDateTime(DateAdd("n", 5, UsrInputStr), 4) & Right(UsrInputStr, 3)
SyslogEndDate = Replace(Replace(ReUsrInputStr, "/", "-"), " ", "T")
 '念のため
If Len(SyslogEndDate) <> 19 Then SyslogEndDate = Left(UsrInputStr, 2) & SyslogEndDate

'(8)テラタームマクロへ引数を渡して起動する。
CheckMsg = ""
CheckMsg = MsgBox("本当に取得を開始しますか？", vbyesno + vbExclamation,"最終確認です")
If CheckMsg = vbNo then
    msgbox "再度ツールを起動してください。",vbInformation
    WScript.Quit
End If
'msgbox SyslogStartDate & " " & SyslogEndDate
Set Shello = CreateObject("WScript.Shell")
Shello.Run """" & ttpmacroPath &""" "& ScrPath & UseFilesName(0) & " "& SyslogStartDate &" "& SyslogEndDate &" "& _
  LogsSavePath &" "& LogFilesName(0) &" "& LogFilesName(1) &" "& ScrPath & UseFilesName(1) & " " & ResPath & " " & StartDate
Set Shello = Nothing

'VBSでの処理は終了
;GetFileInfo.ttl
;推奨バージョン:4.62以上

;(1)batファイルから受け取ったシステム変数の確認。
 ;ttlファイル単体で実行された場合、エラーを表示し終了。
if paramcnt = 1 then
  messagebox 'このファイル単体で実行せず、vbsから起動してください。' '実行エラー' 
  end 
endif

;(2)使用する変数を設定
 ;パラメータを変数へ設定
StartDate = params[2]  ;ログ取得開始日時
EndDate = params[3]  ;ログ取得終了日時
LogsSavePath  = params[4]  ;ログを保存するパス
LogsSaveFileName1  = params[5]  ;操作ログ1.txt
LogsSaveFileName2  = params[6]  ;操作ログ2.txt
CountVBSFileName = params[7]  ;起動する集計VBS
RsuPath = params[8]  ;集計VBSへ引き渡す「結果」のパス
UserStartDate = params[9]  ;集計VBSツールを起動した日時
 ;パラメータ以外を変数へ設定
SyslogServerIp = ''  ;サーバのIP
SyslogFilePath = ''  ;サーバ上のログファイルのパス
SyslogFileName = ''  ;サーバ上のログファイル名
ArchiveSyslogFileName = SyslogFileName  ;サーバ上のアーカイブされたログファイル名
CheckLoop = 1 ;サーバ上のログ収集のループカウント
 ;メッセージを取得するファイル名の配列
strdim SyslogFileNameAry 2
;SyslogFileNameAry[0]は必要に応じてアーカイブファイル名を設定します。
SyslogFileNameAry[1] = SyslogFileName

;(2)IDとパスワードを入力
inputbox 'ユーザ名の入力をお願いします。' 'ユーザ名の入力' 
UserName = inputstr 
passwordbox 'パスワードの入力をお願いします。' 'パスワードの入力'
 ;接続コマンド組立て 
Command = SyslogServerIp
strconcat Command ':22 /ssh /2 /auth=password /user=' 
strconcat Command UserName
strconcat Command ' /passwd=' 
strconcat Command inputstr
 ;syslogサーバへ接続 
connect Command

;(3)接続できなかった場合、エラーメッセージを表示し終了。
;; 接続判定①（接続出来ない場合はメッセージを表示しマクロ終了） 
if result <> 2 then 
 messagebox 'Syslogサーバへ接続できませんでした。Syslogサーバの状態を確認してください。' 'エラー接続できませんでした' 
 end 
endif
;; 接続判定②（接続して10秒以内にプロンプトが表示されない場合もマクロ終了） 
timeout = 10
 wait '$' '#'
if result = 0 then
 messagebox 'Syslogサーバへ接続できませんでした。' 'エラー接続できませんでした' 
 messagebox 'ユーザ名やパスワードが間違っている可能性があります。「Syslog集計起動VBS.vbs」から再実行してください。' 'エラー接続できませんでした'   
 end 
endif

;操作ログの取得開始
LogsSaveFullPath = LogsSavePath
strconcat LogsSaveFullPath LogsSaveFileName1
;ユーザ名と開始日時を書き込む
fileopen fhandle LogsSaveFullPath 0
Str = 'UserName:'
strconcat Str UserName
filewriteln fhandle Str
Str = 'StartDateTime:'
gettime TimeStr "%Y/%m/%d %H:%M:%S"
strconcat Str TimeStr
filewriteln fhandle Str
fileclose fhandle
;取得開始
logopen LogsSaveFullPath 0 1

;(4)cdコマンドにてディレクトリへ移動
 ;シェルスクリプトでディレクトリの存在を確認
CheckDirCommand = 'dir='
strconcat CheckDirCommand SyslogFilePath
strconcat CheckDirCommand '; [ -d "$dir" ] ; echo $?'
sendln CheckDirCommand
wait '$' '#'
 ;サーバに出力された情報を取得
for i 0 1
  recvln
  str2int CheckResult inputstr
next
 ;取得した結果をもとに判別、存在しない場合メッセージを表示して終了。
if CheckResult = 1 then
  ErrorMsg = SyslogFilePath
  strconcat ErrorMsg '（ディレクトリ）が存在しません。サーバへログインし状況を確認してください。'
  messagebox ErrorMsg 'ディレクトリが存在しません。'
  end
endif
 ;ディレクトリが存在する場合のみ移動
CdCommand = 'cd '
strconcat CdCommand SyslogFilePath
sendln CdCommand
wait '$' '#'

;(5)特定のファイルの１行目を表示して読み込む
 ;ファイルの存在を確認
CheckFileName = SyslogFileName
call subFileCheck
 ;ファイルが存在しない場合のみ、メッセージを表示し終了。
if CheckResult = 1 then
  ErrorMsg = CheckFileName
  strconcat ErrorMsg '（ファイル）が存在しません。サーバへログインし状況を確認してください。'
  messagebox ErrorMsg 'ファイルが存在しません。'
  end
endif
 ;ファイルが存在する場合のみ一行取得
GetFirstLine = 'sed -n 1p '
strconcat GetFirstLine SyslogFileName
strconcat GetFirstLine ' | awk '#$27'{ sub(/.*c/,"",$2); print $2}'#$27''
sendln  GetFirstLine
wait '$' '#'
for i 0 1
 recvln
 ServerInputStr = inputstr
next
messagebox ServerInputStr 'debug'

;(6)読み込んだ文字列と入力された日付と比較する。
 ;パラメータと取得した文字列の比較準備
ParamData = StartDate
ServerInputDate = ServerInputStr
strreplace ParamData 1 'T' ''
strreplace ServerInputDate 1 'T' ''
for i 0 1
 strreplace ParamData 1 '-' ''
 strreplace ParamData 1 ':' ''
 strreplace ServerInputDate 1 '-' ''
 strreplace ServerInputDate 1 ':' ''
next
messagebox ServerInputDate 'debug'
messagebox ParamData 'debug'
 ;数値へ変換
str2int ComparGetDate ServerInputDate
str2int ComparParamData ParamData
 ;入力された値が小さい場合(古い)、アーカイブファイル名を生成し、配列(0)へ入れる。
if ComparParamData < ComparGetDate then
  ;アーカイブファイル名を生成し、配列(0)へ入れる
 gettime timestr "-%Y%m%d"
 strconcat ArchiveSyslogFileName timestr
 SyslogFileNameAry[0] = ArchiveSyslogFileName
 CheckLoop = 0
  ;ファイルの存在を確認
 CheckFileName = ArchiveSyslogFileName
 call subFileCheck
  ;ファイルが存在しない場合
 if CheckResult = 1 then 
   ErrorMsg = CheckFileName
   strconcat ErrorMsg '（ファイル）が存在しません。まだアーカイブされていない可能性があります。'
   messagebox ErrorMsg 'アーカイブファイルが存在しません。'
   ErrorMsg = SyslogFileName
   strconcat ErrorMsg '（ファイル）の情報取得のみ開始します。'
   messagebox ErrorMsg 'アーカイブファイルが存在しません。'
   CheckLoop = 1
 endif
endif

;操作ログ取得終了
logclose

;(7)操作ログ2取得開始
LogsSaveFullPath = LogsSavePath
strconcat LogsSaveFullPath LogsSaveFileName2
logopen LogsSaveFullPath 0 0

;(8)FORコマンドで カウント変数 1でループする
;長すぎるので最初と最後の文字をsub(/最初.*最後/,"",$2)ってやる
for i CheckLoop 1
   ;(9)ファイルから指定範囲の情報を表示するコマンドを組み立て。
  GetInfoCommand = 'awk '#$27'{ sub(/ccccccccccccc/," ",$2); print}'#$27' '
  strconcat GetInfoCommand SyslogFileNameAry[i]
  strconcat GetInfoCommand ' | awk '#$27'"'
  strconcat GetInfoCommand StartDate
  strconcat GetInfoCommand '" <= $3 && $3 <= "'
  strconcat GetInfoCommand EndDate
  strconcat GetInfoCommand '"'#$27''
  messagebox GetInfoCommand 'debug'
   ;サーバへコマンドを渡す。
  sendln GetInfoCommand
  wait '$' '#'
next

;(10)ログオフ
wait '$' '#'
sendln 'exit'

;(11)集計VBSの起動
StartEndDate = StartDate
strconcat StartEndDate '～'
strconcat StartEndDate EndDate
VBSStartUp = 'wscript.exe '
strconcat VBSStartUp CountVBSFileName
strconcat VBSStartUp ' '
strconcat VBSStartUp RsuPath
strconcat VBSStartUp ' '
strconcat VBSStartUp LogsSavePath
strconcat VBSStartUp ' '
strconcat VBSStartUp LogsSaveFileName1
strconcat VBSStartUp ' '
strconcat VBSStartUp LogsSaveFileName2
strconcat VBSStartUp ' '
strconcat VBSStartUp StartEndDate
strconcat VBSStartUp ' '
strconcat VBSStartUp UserStartDate
strconcat VBSStartUp ' '
strconcat VBSStartUp UserName
exec VBSStartUp

;マクロ終了 
end
;マクロ上での操作は終了
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ファイルの存在確認サブルーチン
 ;CheckFileNameが確認対象です。
 ;ファイルが存在する場合、CheckResultに0を入れる(数値型)
 ;ファイルが存在しない場合、CheckResultに1を入れる(数値型)
:subFileCheck
  ;シェルスクリプトでファイルの存在を確認
 CheckFileCommand = 'file='
 strconcat CheckFileCommand CheckFileName
 strconcat CheckFileCommand '; [ -f "$file" ] ; echo $?'
 sendln CheckFileCommand
 wait '$' '#'
  ;サーバに出力された情報を取得
 for i 0 1
  recvln
  str2int CheckResult inputstr
 next
return
;CountIPAddressOutput.vbs
Option Explicit
'(1)受け取ったシステム変数の確認。
If Wscript.Arguments.Count = 0 then
'  MsgBox "このファイル単体で実行せず、Syslog集計起動VBS.vbsから起動してください。", vbCritical,"実行エラー"
'  WScript.Quit
End if

'(2)使用する変数の設定
Dim ResPath '集計結果を格納するパス
Dim LogsSavePath '操作ログを格納するパス
Dim LogFileName1 '操作ログ1.txt
Dim LogFileName2 '操作ログ2.txt
Dim TotalResultFileName '集計結果を記録するファイル名
Dim Fso, oLog, oRsu, MvFso '各種オブジェクト用
Dim SyslogStartEndDate 'サーバから取得した日時範囲
Dim UserStartDate '作業を開始した日時
Dim UserName '作業を行ったユーザ名
Dim SearchStr '集計作業に用いる変数
Dim TimeStr 'ファイル名変更に用いる変数
Dim i, j, k, count, Check 'カウント用変数
Dim tmp, tmp2 '並び替えに用いる変数
Dim TextArr() 'テキストの内容を格納する配列
Dim ResultArr() '集計結果を格納する配列

ResPath = Wscript.Arguments(0)
LogsSavePath = Wscript.Arguments(1)
LogFileName1 = Wscript.Arguments(2)
LogFileName2 = Wscript.Arguments(3)
SyslogStartEndDate = Wscript.Arguments(4)
UserStartDate = Wscript.Arguments(5)
UserStartDate = Replace(UserStartDate, "　"," ")
UserName = Wscript.Arguments(6)
Set Fso = CreateObject("Scripting.FileSystemObject")

'(3)集計結果ファイルの存在確認および作成
'存在確認
TimeStr = Replace(Replace(Replace(Now(), "/", ""), ":", ""), " ", "")
TotalResultFileName = TimeStr & "_Syslog集計結果"
TotalResultFileName = CheckFile(TotalResultFileName & "*", ResPath, 1, TotalResultFileName)
'作成
Fso.CreateTextFile ResPath & TotalResultFileName
Set oLog = Fso.CreateTextFile(ResPath & TotalResultFileName)
oLog.WriteLine("①作業開始時刻：" & UserStartDate & vbCrLf & "②作業実施アカウント名：" & UserName & vbCrLf & "③集計期間：" & SyslogStartEndDate & vbCrLf & "④集計結果：")
oLog.Close()

'(4)ログファイルの確認。
For i = 1 To 2
  If Fso.FileExists(LogsSavePath & "操作ログ" & i & ".txt") = False Then
    MsgBox "「ログ」フォルダに「操作ログ" & i & ".txt」が存在しません。" & vbCr & _
           "Syslogサーバから正常に操作ログを取得できなかった可能性があります。"  & vbCr & _
           "詳細は「結果」のフォルダ内の" & TotalResultFileName & "を確認してください。", vbCritical,"使用するファイルがありません"
    Set oLog = Fso.OpenTextFile(ResPath & TotalResultFileName, 8, True)
    oLog.WriteLine("IPアドレスの集計ができませんでした。" & vbCr & _
                   "「ログ」フォルダに「" & LogFileName & "」が存在しないため実行できませんでした。"  & vbCr & _
                   "Syslogサーバから正常に取得できなかった可能性があります。" & vbCr & _
                   "手順書を参照しWinRMから情報を取得してください。")
    '事後処理
    oLog.WriteLine("⑤作業終了時刻：" & Now())
    oLog.Close
    Set Fso = Nothing
    'ツール終了
    Msgbox "全ての処理が完了しました。"
    WScript.Quit
  End if
Next

'(5)操作ログ2.txtの内容の確認。
Set oRsu = Fso.OpenTextFile(LogsSavePath & LogFileName2)
i = 0
'AtEndOfLine が True になるまでループ
Do While oRsu.AtEndOfLine <> True
  '配列の要素数を変更
  ReDim Preserve TextArr(i)
  TextArr(i) = oRsu.ReadLine
  i = i + 1
Loop
oRsu.Close

'(6)文字列の集計処理
'ファイル内に何も記載されていなかった場合
If i = 0 Then
  MsgBox "集計対象がありません。Syslogサーバから正常に操作ログを取得できなかった可能性があります。" & vbCr & _
        "詳細は「結果」のディレクトリ内の" & TotalResultFileName & "を確認してください。",vbExclamation,"IPアドレスの集計ができませんでした"
  Set oLog = Fso.OpenTextFile(ResPath & TotalResultFileName, 8, True)
  oLog.WriteLine("IPアドレスの集計ができませんでした。" & vbCr & _
                 "集計対象ファイルに何も記載がありません。Syslogサーバから正常に取得できなかった可能性があります。" & vbCr & _
                 "手順書を参照しWinRMから情報を取得してください。また、操作ログは以下に格納されています。" & vbCr & _
                 "操作ログ1：" & LogsSavePath & TimeStr & "_" & LogFileName1 & vbCr & "操作ログ2：" & LogsSavePath & TimeStr & "_" & LogFileName2)
  '事後処理
  oLog.WriteLine("⑤作業終了時刻：" & Now())
  oLog.Close
  Set MvFso = Fso.GetFile(LogsSavePath & LogFileName1)
  MvFso.Name = TimeStr & "_" & LogFileName1
  Set MvFso = Fso.GetFile(LogsSavePath & LogFileName2)
  MvFso.Name = TimeStr & "_" & LogFileName2
  Set Fso = Nothing
  'ツール終了
  Msgbox "全ての処理が完了しました。"
  WScript.Quit
end if
'正常にログが取得ができた場合の処理
SearchStr = "ccccc"
for i = 0 to Ubound(TextArr)
  If i > 0 And i < 3 Then
    If InStr(left(TextArr(i), 5), SearchStr) = 1 then
      ReDim ResultArr(1, 0)
      '★
      ResultArr(0, 0) = Mid(TextArr(i), 53 , 1)
      ResultArr(1, 0) = 1
      'ループ①条件：ファイルの行数分(引数として受け取った行数)ループをする
      For j = i + 1 to Ubound(TextArr)
        '条件分岐②条件：特定の文字かどうか確認
        If InStr(left(TextArr(j), 5), SearchStr) = 1 then
          '特定の文字の場合の処理
          'ループ②条件：配列の数だけ
          Check = 0
          For k = 0 to UBound(ResultArr, 2)
            '条件分岐③条件：配列内(1番目)に存在する文字かどうか確認
            If Mid(TextArr(j), 53, 1) = ResultArr(0, k) Then
              ResultArr(1, k) = ResultArr(1, k) + 1
              Check = Check + 1
              Exit For
            End if
          Next
          '条件分岐④条件：配列ないの存在をチェックする変数が0か確認
          If Check = 0 Then
            ReDim Preserve ResultArr(1 ,UBound(ResultArr, 2) + 1)
            '★
            ResultArr(0, UBound(ResultArr, 2)) = Mid(TextArr(j), 53, 1)
            ResultArr(1, UBound(ResultArr, 2)) = 1
          End if
        End if
      Next
      '降順へ並び替え
      For j = 0 to UBound(ResultArr, 2) - 1
        For k = j + 1 to UBound(ResultArr, 2)
          if CLng(ResultArr(1, j)) < CLng(ResultArr(1, k)) then
            tmp = ResultArr(0, k)
            tmp2 = ResultArr(1, k)
            ResultArr(0, k) = ResultArr(0, j)
            ResultArr(1, k) = ResultArr(1, j)
            ResultArr(0, j) = tmp
            ResultArr(1, j) = tmp2
          end if
        next
      Next
      '集計結果をファイルへ出力
      Set oLog = Fso.OpenTextFile(ResPath & TotalResultFileName, 8, True)
      For j = 0 to UBound(ResultArr, 2)
        oLog.WriteLine("  対象文字列：" & ResultArr(0, j) & "	発生回数：" & ResultArr(1, j))
      Next
      MsgBox "正常に集計が実施できました！！"
      Exit for
    End if
  Elseif i = 3 then
    Exit for
  End if
Next
if i = 2 Or i = 3 then
  MsgBox "集計対象がありません。Syslogサーバから正常に取得できなかった可能性があります。" & vbCr & _
         "詳細は結果のディレクトリ内の" & TotalResultFileName & "を確認してください。",vbExclamation,"IPアドレスの集計ができませんでした"
  Set oLog = Fso.OpenTextFile(ResPath & TotalResultFileName, 8, True)
  oLog.WriteLine("IPアドレスの集計ができませんでした。" & vbCr & _
                 "コマンドは記載されていますが集計対象がありません。Syslogサーバから正常に取得できなかった可能性があります。" & vbCr & _
                 "手順書を参照しWinRMから情報を取得してください。また、操作ログは以下に格納されています。" & vbCr & _
                 "操作ログ1：" & LogsSavePath & TimeStr & "_" & LogFileName1 & vbCr & "操作ログ2：" & LogsSavePath & TimeStr & "_" & LogFileName2)
End if
'事後処理
oLog.WriteLine("⑤作業終了時刻：" & Now())
oLog.Close
Set MvFso = Fso.GetFile(LogsSavePath & LogFileName1)
MvFso.Name = TimeStr & "_" & LogFileName1
Set MvFso = Fso.GetFile(LogsSavePath & LogFileName2)
MvFso.Name = TimeStr & "_" & LogFileName2
Set Fso = Nothing
'ツール終了
Msgbox "全ての処理が完了しました。"
'すべての処理が完了
''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ファイル名がかぶった時のファイル名変更
Function CheckFile(fileName, folderName, i , org)
  Set fso = CreateObject("Scripting.FileSystemObject")
  On Error Resume Next
  fso.CopyFile folderName & fileName, folderName
  if Err.Number <> 53 Then
    i = i + 1
    fileName = org & "(" & i & ")"
    CheckFile=CheckFile(fileName & "*", folderName, i, org)
  else
    CheckFile=org & "(" & i & ").txt"
    if 1 = i then CheckFile=org & ".txt"
  end if
End Function
